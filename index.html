import React, { useEffect, useMemo, useState } from "react";

// Poker 2025/2026 â€“ Dashboard mÃ³vil v1.0 (React + Tailwind CSS)
// âœ… Optimizado para mÃ³vil (vertical)
// âœ… EstÃ©tica minimalista con look & feel de poker
// âœ… Registro de jugadores (hasta 15) con foto anÃ³nima clickable para subir foto
// âœ… Seguimiento de pagos (No pagado por defecto / Pagado con toggle)
// âœ… Calendario de partidas (fechas oficiales + partidas flotantes hasta 6/aÃ±o)
// âœ… Cada fecha tiene 2 mesas, con: anfitriÃ³n (comÃºn), finalistas 1Âº/2Âº/3Âº y 2 fotos (mesa1/mesa2)
// âœ… Integrantes por mesa (seleccionables de la lista de jugadores) + secciÃ³n desplegable
// âœ… ClasificaciÃ³n general (suma de mejores 12 mesas por jugador; 1Âº=6, 2Âº=3, 3Âº=1)
// âœ… Exportar / Importar JSON para copias de seguridad
// âœ… SecciÃ³n de REGLAS con el texto proporcionado (con emojis)
// âœ… Persistencia local (localStorage) y sin dependencias externas

/************************************
 * Utilidades y datos iniciales
 ************************************/
const MAX_PLAYERS = 15;
const MAX_FLOATING_PER_YEAR = 6;

const OFFICIAL_DATES = [
  { date: "2025-09-12", label: "12 Septiembre 2025 (ya jugada)" },
  { date: "2025-09-26", label: "26 Septiembre 2025" },
  { date: "2025-10-24", label: "24 Octubre 2025" },
  { date: "2025-11-21", label: "21 Noviembre 2025" },
  { date: "2025-12-12", label: "12 Diciembre 2025" },
  { date: "2026-01-30", label: "30 Enero 2026" },
  { date: "2026-02-27", label: "27 Febrero 2026" },
  { date: "2026-03-27", label: "27 Marzo 2026" },
  { date: "2026-04-24", label: "24 Abril 2026" },
  { date: "2026-05-29", label: "29 Mayo 2026" },
  { date: "2026-06-12", label: "12 Junio 2026 (Gran Final)" },
];

const EMPTY_AVATAR =
  "data:image/svg+xml;utf8," +
  encodeURIComponent(`<?xml version='1.0' encoding='UTF-8'?>
  <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'>
    <rect width='128' height='128' rx='16' fill='#0c7c3a'/>
    <circle cx='64' cy='48' r='22' fill='#e6f7ef'/>
    <rect x='24' y='78' width='80' height='34' rx='17' fill='#e6f7ef'/>
  </svg>`);

function uid() {
  return Math.random().toString(36).slice(2, 10);
}

function save(key, value) {
  localStorage.setItem(key, JSON.stringify(value));
}
function load(key, fallback) {
  try {
    const v = localStorage.getItem(key);
    return v ? JSON.parse(v) : fallback;
  } catch {
    return fallback;
  }
}

/************************************
 * Componentes UI bÃ¡sicos
 ************************************/
function AppHeader() {
  return (
    <div className="sticky top-0 z-40 bg-green-700 text-white">
      <div className="flex items-center gap-3 px-4 py-3">
        <LogoBadge />
        <div className="leading-tight">
          <div className="text-xs uppercase tracking-widest opacity-90">Dashboard</div>
          <h1 className="text-lg font-semibold">Poker 2025/2026</h1>
        </div>
      </div>
    </div>
  );
}

function LogoBadge() {
  return (
    <div className="flex items-center gap-2">
      <div className="bg-white/10 backdrop-blur px-3 py-2 rounded-xl border border-white/20">
        <div className="flex items-center gap-2">
          <PlayingCardIcon />
          <span className="font-medium">Texas Holdâ€™em Poker</span>
        </div>
      </div>
    </div>
  );
}

function PlayingCardIcon() {
  return (
    <svg aria-hidden className="w-6 h-6" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect x="5" y="2" width="14" height="20" rx="2" className="fill-white/90" />
      <rect x="7" y="4" width="10" height="16" rx="1" className="fill-green-600" />
      <path d="M12 8l2 3h-4l2-3zm0 8l-2-3h4l-2 3z" className="fill-white" />
    </svg>
  );
}

function TabBar({ tab, setTab }) {
  const tabs = [
    { id: "jugadores", label: "ğŸ‘¤ Jugadores" },
    { id: "partidas", label: "ğŸ—“ Partidas" },
    { id: "clasificacion", label: "ğŸ† ClasificaciÃ³n" },
    { id: "reglas", label: "ğŸ“œ Reglas" },
    { id: "copias", label: "ğŸ’¾ Copias" },
  ];
  return (
    <div className="sticky top-[60px] z-30 bg-white border-b border-gray-200">
      <div className="flex overflow-x-auto no-scrollbar">
        {tabs.map((t) => (
          <button
            key={t.id}
            className={`shrink-0 px-4 py-3 text-sm font-medium border-b-2 transition-colors ${
              tab === t.id ? "border-green-600 text-green-700" : "border-transparent text-gray-600"
            }`}
            onClick={() => setTab(t.id)}
          >
            {t.label}
          </button>
        ))}
      </div>
    </div>
  );
}

/************************************
 * Modelo de datos
 ************************************/
const defaultPlayers = Array.from({ length: MAX_PLAYERS }).map((_, i) => ({
  id: uid(),
  name: "",
  photo: "",
  paid: false, // por defecto No pagado
}));

const defaultPartidas = OFFICIAL_DATES.map((d) => ({
  id: uid(),
  date: d.date,
  label: d.label,
  isFloating: false,
  host: "",
  mesas: [
    {
      id: uid(),
      name: "Mesa 1",
      finalists: { first: "", second: "", third: "" },
      integrantes: [],
      photo: "",
    },
    {
      id: uid(),
      name: "Mesa 2",
      finalists: { first: "", second: "", third: "" },
      integrantes: [],
      photo: "",
    },
  ],
}));

const defaultState = {
  players: defaultPlayers,
  partidas: defaultPartidas,
};

/************************************
 * Helpers clasificaciÃ³n
 ************************************/
function computeLeaderboard(players, partidas) {
  // Recoge todos los podios mesa a mesa, suma puntos (6/3/1) y se queda con las 12 mejores mesas por jugador
  const scoresByPlayer = new Map();

  function addScore(name, pts) {
    if (!name) return;
    const key = name.trim().toLowerCase();
    if (!key) return;
    const arr = scoresByPlayer.get(key) || [];
    arr.push(pts);
    scoresByPlayer.set(key, arr);
  }

  partidas.forEach((p) => {
    p.mesas.forEach((m) => {
      addScore(m.finalists.first, 6);
      addScore(m.finalists.second, 3);
      addScore(m.finalists.third, 1);
    });
  });

  const rows = [];
  // Preferimos el nombre escrito como en jugadores, si existe
  const nameMap = new Map();
  players.forEach((pl) => {
    if (pl.name) nameMap.set(pl.name.trim().toLowerCase(), pl.name.trim());
  });

  for (const [key, arr] of scoresByPlayer.entries()) {
    const sorted = [...arr].sort((a, b) => b - a).slice(0, 12);
    const total = sorted.reduce((s, x) => s + x, 0);
    rows.push({ name: nameMap.get(key) || key, total, best12Count: sorted.length });
  }

  // Jugadores sin puntos: aparecen con 0 si estÃ¡n en el registro
  players
    .filter((p) => p.name.trim())
    .forEach((p) => {
      const key = p.name.trim().toLowerCase();
      if (!scoresByPlayer.has(key)) rows.push({ name: p.name.trim(), total: 0, best12Count: 0 });
    });

  return rows.sort((a, b) => b.total - a.total || a.name.localeCompare(b.name));
}

/************************************
 * Subcomponentes funcionales
 ************************************/
function PhotoInput({ value, onChange, label, fullContain = true }) {
  const handleFile = (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    onChange(url);
  };
  return (
    <div className="flex flex-col items-center gap-2">
      <label className="w-24 h-24 rounded-xl overflow-hidden bg-green-50 border border-green-200 flex items-center justify-center">
        {value ? (
          <img
            src={value}
            alt={label}
            className={`w-full h-full ${fullContain ? "object-contain" : "object-cover"}`}
          />
        ) : (
          <img src={EMPTY_AVATAR} alt="anÃ³nimo" className="w-full h-full object-contain" />
        )}
        <input type="file" accept="image/*" className="hidden" onChange={handleFile} />
      </label>
      {label && <span className="text-xs text-gray-600">{label}</span>}
    </div>
  );
}

function TogglePaid({ paid, onToggle }) {
  return (
    <div className="flex w-full rounded-xl overflow-hidden border text-sm">
      <button
        className={`flex-1 px-3 py-2 font-medium ${paid ? "bg-white text-gray-700" : "bg-red-600 text-white"}`}
        onClick={() => onToggle(false)}
      >
        No pagado
      </button>
      <button
        className={`flex-1 px-3 py-2 font-medium ${paid ? "bg-green-600 text-white" : "bg-white text-gray-700"}`}
        onClick={() => onToggle(true)}
      >
        Pagado
      </button>
    </div>
  );
}

function PlayerCard({ player, onChange }) {
  return (
    <div className="p-3 bg-white rounded-2xl shadow-sm border flex gap-3 items-center">
      <PhotoInput value={player.photo} onChange={(url) => onChange({ ...player, photo: url })} />
      <div className="flex-1">
        <input
          className="w-full text-base font-medium bg-transparent outline-none border-b border-gray-200 focus:border-green-600 py-1"
          placeholder="Nombre y apellidos"
          value={player.name}
          onChange={(e) => onChange({ ...player, name: e.target.value })}
        />
        <div className="mt-2">
          <TogglePaid
            paid={player.paid}
            onToggle={(v) => onChange({ ...player, paid: v })}
          />
        </div>
      </div>
    </div>
  );
}

function PodioInputs({ finalists, setFinalists, players }) {
  const options = ["", ...players.map((p) => p.name).filter(Boolean)];
  return (
    <div className="grid grid-cols-1 gap-2">
      <SelectField label="ğŸ¥‡ 1Âº" value={finalists.first} onChange={(v) => setFinalists({ ...finalists, first: v })} options={options} />
      <SelectField label="ğŸ¥ˆ 2Âº" value={finalists.second} onChange={(v) => setFinalists({ ...finalists, second: v })} options={options} />
      <SelectField label="ğŸ¥‰ 3Âº" value={finalists.third} onChange={(v) => setFinalists({ ...finalists, third: v })} options={options} />
    </div>
  );
}

function SelectField({ label, value, onChange, options }) {
  return (
    <label className="flex items-center gap-2 text-sm">
      <span className="w-16 text-gray-700 shrink-0">{label}</span>
      <select
        className="flex-1 px-3 py-2 bg-white border rounded-xl focus:outline-none focus:ring-2 focus:ring-green-500"
        value={value}
        onChange={(e) => onChange(e.target.value)}
      >
        {options.map((op) => (
          <option key={op} value={op}>
            {op || "â€”"}
          </option>
        ))}
      </select>
    </label>
  );
}

function IntegrantesSelector({ value, onChange, players }) {
  const toggle = (id) => {
    const set = new Set(value);
    if (set.has(id)) set.delete(id);
    else set.add(id);
    onChange([...set]);
  };
  return (
    <div className="grid grid-cols-2 gap-2">
      {players.map((p) => (
        <label key={p.id} className="flex items-center gap-2 text-sm bg-white border rounded-xl px-2 py-2">
          <input
            type="checkbox"
            checked={value.includes(p.id)}
            onChange={() => toggle(p.id)}
          />
          <span className="truncate">{p.name || "(vacÃ­o)"}</span>
        </label>
      ))}
    </div>
  );
}

function MesaEditor({ mesa, setMesa, players }) {
  const [open, setOpen] = useState(false);
  return (
    <div className="p-3 bg-white rounded-2xl shadow-sm border space-y-3">
      <div className="flex items-center justify-between">
        <h4 className="font-semibold">{mesa.name}</h4>
        <button className="text-sm text-green-700 underline" onClick={() => setOpen((v) => !v)}>
          {open ? "Ocultar integrantes" : "Mostrar integrantes"}
        </button>
      </div>

      <div className="grid grid-cols-2 gap-3">
        <PhotoInput
          value={mesa.photo}
          onChange={(url) => setMesa({ ...mesa, photo: url })}
          label="Subir foto"
          fullContain
        />
        <PodioInputs
          finalists={mesa.finalists}
          setFinalists={(f) => setMesa({ ...mesa, finalists: f })}
          players={players}
        />
      </div>

      {open && (
        <div className="pt-2">
          <div className="text-xs text-gray-500 mb-2">Selecciona los integrantes de la mesa</div>
          <IntegrantesSelector
            value={mesa.integrantes}
            onChange={(list) => setMesa({ ...mesa, integrantes: list })}
            players={players}
          />
        </div>
      )}
    </div>
  );
}

function PartidaCard({ partida, setPartida, players, floatingCount, canCreateFloating, onCreateFloating }) {
  return (
    <div className="p-3 bg-emerald-50 border border-emerald-200 rounded-2xl space-y-3">
      <div className="flex items-center gap-2">
        <span className="px-2 py-1 text-xs rounded-full bg-emerald-700 text-white">
          {partida.isFloating ? "FLOTANTE" : "OFICIAL"}
        </span>
        <input
          type="date"
          className="px-3 py-2 rounded-xl border bg-white"
          value={partida.date}
          onChange={(e) => setPartida({ ...partida, date: e.target.value })}
        />
        <span className="text-xs text-gray-600">{partida.label || ""}</span>
      </div>

      <label className="flex items-center gap-2 text-sm">
        <span className="w-20 text-gray-700 shrink-0">AnfitriÃ³n</span>
        <select
          className="flex-1 px-3 py-2 bg-white border rounded-xl"
          value={partida.host}
          onChange={(e) => setPartida({ ...partida, host: e.target.value })}
        >
          <option value="">â€”</option>
          {players
            .filter((p) => p.name.trim())
            .map((p) => (
              <option key={p.id} value={p.name}>
                {p.name}
              </option>
            ))}
        </select>
      </label>

      <div className="grid grid-cols-1 gap-3">
        {partida.mesas.map((m, idx) => (
          <MesaEditor
            key={m.id}
            mesa={m}
            setMesa={(newMesa) => {
              const copy = { ...partida, mesas: [...partida.mesas] };
              copy.mesas[idx] = newMesa;
              setPartida(copy);
            }}
            players={players}
          />
        ))}
      </div>

      {canCreateFloating && (
        <div className="flex items-center justify-between pt-2">
          <span className="text-xs text-gray-600">Partidas flotantes creadas: {floatingCount}/{MAX_FLOATING_PER_YEAR}</span>
          <button
            className="px-3 py-2 rounded-xl bg-green-600 text-white text-sm"
            onClick={onCreateFloating}
          >
            + Crear partida flotante
          </button>
        </div>
      )}
    </div>
  );
}

/************************************
 * Vistas principales
 ************************************/
function JugadoresView({ state, setState }) {
  const { players } = state;
  const updatePlayer = (i, p) => {
    const next = [...players];
    next[i] = p;
    setState({ ...state, players: next });
  };

  const filled = players.filter((p) => p.name.trim()).length;

  return (
    <div className="p-4 space-y-3">
      <div className="text-sm text-gray-600">Jugadores: {filled}/{MAX_PLAYERS}</div>
      {players.map((p, i) => (
        <PlayerCard key={p.id} player={p} onChange={(np) => updatePlayer(i, np)} />
      ))}
    </div>
  );
}

function PartidasView({ state, setState }) {
  const { partidas, players } = state;

  const floatingCount = partidas.filter((p) => p.isFloating).length;
  const canCreateFloating = floatingCount < MAX_FLOATING_PER_YEAR;

  const updatePartida = (i, np) => {
    const next = [...partidas];
    next[i] = np;
    setState({ ...state, partidas: next });
  };

  const createFloating = () => {
    if (!canCreateFloating) return;
    const newP = {
      id: uid(),
      date: new Date().toISOString().slice(0, 10),
      label: "(Flotante)",
      isFloating: true,
      host: "",
      mesas: [
        { id: uid(), name: "Mesa 1", finalists: { first: "", second: "", third: "" }, integrantes: [], photo: "" },
        { id: uid(), name: "Mesa 2", finalists: { first: "", second: "", third: "" }, integrantes: [], photo: "" },
      ],
    };
    setState({ ...state, partidas: [...partidas, newP] });
  };

  return (
    <div className="p-4 space-y-4">
      <div className="sticky top-[100px] z-20 -mx-4 px-4 py-2 bg-white/90 backdrop-blur border-b">
        <button
          className="w-full py-3 rounded-2xl bg-green-700 text-white font-medium"
          onClick={createFloating}
          disabled={!canCreateFloating}
        >
          â• Crear partida flotante (mÃ¡x {MAX_FLOATING_PER_YEAR}/aÃ±o)
        </button>
        {!canCreateFloating && (
          <div className="text-xs text-red-600 mt-1">Has alcanzado el mÃ¡ximo de partidas flotantes.</div>
        )}
      </div>

      {partidas
        .slice()
        .sort((a, b) => a.date.localeCompare(b.date))
        .map((p, i) => (
          <PartidaCard
            key={p.id}
            partida={p}
            setPartida={(np) => updatePartida(i, np)}
            players={players}
            floatingCount={floatingCount}
            canCreateFloating={false}
            onCreateFloating={createFloating}
          />
        ))}
    </div>
  );
}

function ClasificacionView({ state }) {
  const rows = useMemo(() => computeLeaderboard(state.players, state.partidas), [state]);
  return (
    <div className="p-4">
      <div className="bg-white border rounded-2xl overflow-hidden">
        <div className="grid grid-cols-6 text-xs font-semibold bg-emerald-700 text-white">
          <div className="col-span-4 px-3 py-2">Jugador</div>
          <div className="px-3 py-2 text-center">Mej.12</div>
          <div className="px-3 py-2 text-center">Puntos</div>
        </div>
        {rows.map((r, idx) => (
          <div key={idx} className="grid grid-cols-6 text-sm border-t">
            <div className="col-span-4 px-3 py-2 flex items-center gap-2">
              <span className="text-gray-500">{idx + 1}.</span>
              <span className="font-medium">{r.name}</span>
            </div>
            <div className="px-3 py-2 text-center text-gray-700">{r.best12Count}</div>
            <div className="px-3 py-2 text-center font-semibold">{r.total}</div>
          </div>
        ))}
        {!rows.length && (
          <div className="px-3 py-6 text-center text-gray-500">Sin resultados aÃºn.</div>
        )}
      </div>
      <div className="text-xs text-gray-500 mt-2">Reglas de puntos: ğŸ¥‡ 6 â€¢ ğŸ¥ˆ 3 â€¢ ğŸ¥‰ 1 (se suman las 12 mejores mesas)</div>
    </div>
  );
}

function ReglasView() {
  return (
    <div className="p-4 space-y-3 text-sm leading-relaxed">
      <h3 className="text-lg font-semibold">ğŸ¯ REGLAS DEL TORNEO</h3>
      <section className="bg-white rounded-2xl border p-3 space-y-2">
        <h4 className="font-semibold">ğŸ’° Entrada</h4>
        <ul className="list-disc pl-5">
          <li>Costo: $50 USD</li>
          <li>ğŸ’³ Pago a: Eliuth Triana</li>
          <li>ğŸ§¾ Los participantes no acumularÃ¡n puntos para la clasificaciÃ³n general hasta confirmar participaciÃ³n y pago</li>
        </ul>
      </section>

      <section className="bg-white rounded-2xl border p-3 space-y-2">
        <h4 className="font-semibold">ğŸƒ Participantes externos</h4>
        <ul className="list-disc pl-5">
          <li>ğŸ‘¥ Pueden jugar en las mesas (a discreciÃ³n del anfitriÃ³n)</li>
          <li>ğŸ† Acceden al premio de la mesa</li>
          <li>ğŸš« No acumulan puntos para el torneo</li>
        </ul>
      </section>

      <section className="bg-white rounded-2xl border p-3 space-y-2">
        <h4 className="font-semibold">ğŸ“… Fechas oficiales</h4>
        <ul className="list-disc pl-5">
          <li>ğŸ—“ 12 Septiembre</li>
          <li>ğŸ—“ 26 Septiembre</li>
          <li>ğŸ—“ 24 Octubre</li>
          <li>ğŸ—“ 21 Noviembre</li>
          <li>ğŸ—“ 12 Diciembre</li>
          <li>ğŸ—“ 30 Enero</li>
          <li>ğŸ—“ 27 Febrero</li>
          <li>ğŸ—“ 27 Marzo</li>
          <li>ğŸ—“ 24 Abril</li>
          <li>ğŸ—“ 29 Mayo</li>
        </ul>
        <div className="pt-2"><b>ğŸ‰ Gran Final</b> â€¢ ğŸ“ Fecha: 12 de Junio</div>
      </section>

      <section className="bg-white rounded-2xl border p-3 space-y-2">
        <h4 className="font-semibold">ğŸ† Sistema de puntuaciÃ³n</h4>
        <ul className="list-disc pl-5">
          <li>ğŸ¥‡ 1er lugar: 6 puntos</li>
          <li>ğŸ¥ˆ 2do lugar: 3 puntos</li>
          <li>ğŸ¥‰ 3er lugar: 1 punto</li>
          <li>ğŸ“Š Se consideran las 12 mejores mesas</li>
          <li>â• Si no se llega a 12, se suman los puntos acumulados</li>
        </ul>
      </section>

      <section className="bg-white rounded-2xl border p-3 space-y-2">
        <h4 className="font-semibold">ğŸ– Finalistas</h4>
        <ul className="list-disc pl-5">
          <li>ğŸ‘‘ Los 6 mejores jugadores acceden a la mesa final</li>
          <li>ğŸ”„ Si alguien no puede asistir, entra el siguiente en la tabla</li>
        </ul>
      </section>

      <section className="bg-white rounded-2xl border p-3 space-y-2">
        <h4 className="font-semibold">âš–ï¸ Desempates</h4>
        <div>1ï¸âƒ£ Veces en 1er lugar 2ï¸âƒ£ Veces en 2do lugar 3ï¸âƒ£ Veces en 3er lugar ğŸ© Veces como anfitriÃ³n</div>
      </section>

      <section className="bg-white rounded-2xl border p-3 space-y-2">
        <h4 className="font-semibold">ğŸ’µ Premios</h4>
        <ul className="list-disc pl-5">
          <li>ğŸ† Ganador de la temporada: $xx.xx</li>
          <li>ğŸƒ Mesa de finalistas:</li>
          <ul className="list-disc pl-8">
            <li>ğŸ¥‡ 1er lugar: $xx.xx</li>
            <li>ğŸ¥ˆ 2do lugar: $xx.xx</li>
            <li>ğŸ¥‰ 3er lugar: $50</li>
          </ul>
        </ul>
      </section>

      <section className="bg-white rounded-2xl border p-3 space-y-2">
        <h4 className="font-semibold">â± Estructura de Blinds</h4>
        <table className="w-full text-sm">
          <thead>
            <tr className="text-left text-gray-600">
              <th className="py-1">ğŸ§® Nivel</th>
              <th className="py-1">ğŸ’µ Small Blind</th>
              <th className="py-1">ğŸ’µ Big Blind</th>
              <th className="py-1">â³ DuraciÃ³n</th>
            </tr>
          </thead>
          <tbody>
            {[
              [1, 50, 100, "15 min"],
              [2, 100, 200, "10 min"],
              [3, 200, 400, "10 min"],
              [4, 300, 600, "10 min"],
              [5, 500, 1000, "10 min"],
              [6, 1000, 2000, "10 min"],
              [7, 2000, 4000, "10 min"],
              [8, 4000, 8000, "10 min"],
              [9, 5000, 10000, "10 min"],
              [10, 10000, 20000, "10 min"],
            ].map((r) => (
              <tr key={r[0]} className="border-t">
                <td className="py-1">{r[0]}</td>
                <td className="py-1">{r[1]}</td>
                <td className="py-1">{r[2]}</td>
                <td className="py-1">{r[3]}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </section>

      <section className="bg-white rounded-2xl border p-3 space-y-2">
        <h4 className="font-semibold">ğŸ“œ REGLAS GENERALES</h4>
        <ul className="list-disc pl-5">
          <li>ğŸƒ Dealer inicial: carta mÃ¡s alta (en empate, se reparte otra)</li>
          <li>ğŸ§â€â™‚ï¸ Final de mesa: cuando quedan 3 jugadores</li>
          <li>âš”ï¸ EliminaciÃ³n simultÃ¡nea: se usa el stack inicial para definir posiciÃ³n</li>
          <li>ğŸ’± Cambio de fichas: se reemplazan fichas pequeÃ±as por grandes; fracciones se redondean</li>
          <li>âŒ Misdeals:
            <ul className="list-disc pl-5 mt-1">
              <li>ğŸƒ Cartas expuestas por el dealer</li>
              <li>ğŸƒ MÃ¡s de 2 cartas adicionales en mano inicial</li>
              <li>ğŸƒ Cartas encajonadas</li>
              <li>ğŸƒ Reparto a asiento vacÃ­o o falta de reparto a jugador activo</li>
              <li>ğŸƒ Reparto fuera de secuencia</li>
              <li>ğŸƒ Cantidad incorrecta de cartas (si no se puede corregir sin alterar secuencia)</li>
            </ul>
          </li>
        </ul>
      </section>
    </div>
  );
}

function CopiasView({ state, setState }) {
  const exportJson = () => {
    const blob = new Blob([JSON.stringify(state, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "poker_dashboard_backup.json";
    a.click();
    URL.revokeObjectURL(url);
  };

  const importJson = (file) => {
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const data = JSON.parse(String(reader.result));
        if (data && data.players && data.partidas) {
          setState(data);
        } else {
          alert("Archivo invÃ¡lido");
        }
      } catch (e) {
        alert("Error al leer el JSON");
      }
    };
    reader.readAsText(file);
  };

  return (
    <div className="p-4 space-y-3">
      <div className="bg-white border rounded-2xl p-4">
        <h4 className="font-semibold mb-2">Copias de seguridad</h4>
        <div className="flex flex-col gap-2">
          <button className="px-4 py-3 rounded-2xl bg-green-700 text-white" onClick={exportJson}>
            â¬‡ï¸ Exportar JSON
          </button>
          <label className="px-4 py-3 rounded-2xl border bg-white text-center">
            â¬†ï¸ Importar JSON
            <input
              type="file"
              accept="application/json"
              className="hidden"
              onChange={(e) => e.target.files?.[0] && importJson(e.target.files[0])}
            />
          </label>
          <p className="text-xs text-gray-500">Consejo: comparte el JSON en el grupo para que cualquiera pueda restaurar el estado.</p>
        </div>
      </div>
    </div>
  );
}

/************************************
 * App principal
 ************************************/
export default function App() {
  const [tab, setTab] = useState("jugadores");
  const [state, setState] = useState(() => load("poker_state_v1", defaultState));

  // Persistencia automÃ¡tica
  useEffect(() => {
    save("poker_state_v1", state);
  }, [state]);

  return (
    <div className="min-h-[100dvh] bg-emerald-100/40 text-gray-900">
      <AppHeader />
      <TabBar tab={tab} setTab={setTab} />

      {tab === "jugadores" && <JugadoresView state={state} setState={setState} />}
      {tab === "partidas" && <PartidasView state={state} setState={setState} />}
      {tab === "clasificacion" && <ClasificacionView state={state} />}
      {tab === "reglas" && <ReglasView />}
      {tab === "copias" && <CopiasView state={state} setState={setState} />}

      <footer className="py-12" />
    </div>
  );
}
